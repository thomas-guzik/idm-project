/*
 * generated by Xtext 2.23.0
 */
package idm.validation

import idm.qsv.Column
import idm.qsv.ColumnDescription
import idm.qsv.ColumnInsertion
import idm.qsv.ColumnNames
import idm.qsv.Compute
import idm.qsv.Delete
import idm.qsv.Echo
import idm.qsv.Insert
import idm.qsv.Insertion
import idm.qsv.Print
import idm.qsv.QsvPackage
import idm.qsv.QuerySeparatedValues
import idm.qsv.Statement
import idm.qsv.Update
import java.util.ArrayList
import java.util.List
import org.eclipse.xtext.validation.Check

/** 
 * This class contains custom validation rules.
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class QsvChecksValidator extends AbstractQsvValidator {
	public static final String INVALID_NAME_USAGE = "invalidNameUsage"
	public static final String UNDEFINED_VARIABLE = "undefinedVariable"

	@Check(FAST)
	def void checkNamesUsedOnlyIfColumnsHaveNames(QuerySeparatedValues qsv) {
		var boolean hasColumnNames = qsv.getHeader().isHasColumnName()
		var List<Statement> statements = qsv.getStatements()
		if (!hasColumnNames) {
			for (Statement statement : statements) {
				if (statement.hasNames) {
					error("Please do not use column names for data with no headers.",
						QsvPackage.Literals.QUERY_SEPARATED_VALUES__HEADER, INVALID_NAME_USAGE)
					return
				}
			}
		}
	}

	def dispatch boolean hasNames(Statement statement) {
		return false
	}

	def dispatch boolean hasNames(Print print) {
		val selector = print.selector
		if (selector !== null) {
			val columnSelection = selector.columnSelection
			if (columnSelection !== null) {
				return columnSelection.columns.hasNames()
			}
		}
		return false
	}

	def dispatch boolean hasNames(Insert insert) {
		return insert.inserted.hasNames()
	}

	def dispatch boolean hasNames(Delete delete) {
		val selector = delete.selector
		val columnSelection = selector.columnSelection
		if (columnSelection !== null) {
			return columnSelection.columns.hasNames()
		}
		return false
	}

	def dispatch boolean hasNames(Update update) {
		return update.columns.hasNames
	}

	def dispatch boolean hasNames(Insertion column) {
		return false
	}

	def dispatch boolean hasNames(ColumnInsertion column) {
		for (ColumnDescription description : column.descriptions) {
			if (description.columnName !== null) {
				return true
			}
		}
		return false
	}

	def dispatch boolean hasNames(Column column) {
		return false
	}

	def dispatch boolean hasNames(ColumnNames column) {
		return true
	}

	@Check def void checkVariablesHaveBeenDefined(QuerySeparatedValues qsv) {
		val statements = qsv.getStatements()
		val defined = new ArrayList<String>()
		for (Statement statement : statements) {
			defined.addAll(statement.definedVariables())
			val used = statement.usedVariables()
			for (String variable : used) {
				if (!defined.contains(variable)) {
					error("Please define variables before use.", QsvPackage.Literals.QUERY_SEPARATED_VALUES__STATEMENTS,
						UNDEFINED_VARIABLE)
				}
			}
		}
	}

	def dispatch List<String> usedVariables(Statement statement) {
		return List.of()
	}

	def dispatch List<String> usedVariables(Echo echo) {
		return List.of(echo.variable.value)
	}

	def dispatch List<String> definedVariables(Statement statement) {
		return List.of()
	}

	def dispatch List<String> definedVariables(Compute compute) {
		return List.of(compute.variable.value)
	}

}
